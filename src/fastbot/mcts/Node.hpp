
#pragma once

#include "../../util/Common.hpp"
#include "../Action.hpp"
#include "../Spec.hpp"
#include "../State.hpp"

namespace fastbot {
namespace mcts {

// A node of a search tree.
class Node {
public:
  using Edge = pair<Action, uptr<Node>>;

  Node(const State &state, unsigned char playerIndex, unsigned depth);
  virtual ~Node() = default;

  bool IsLeaf(void) const;
  unsigned char PlayerIndex(void) const;
  State GetState(void) const;

  vector<pair<Action, float>> GetActionUtilities(void) const;

  // TODO: should add a policy object as input that will choose which action to expand.
  // Returns a new node that is generated by an action from this node.
  Node *Expand(void); // Can only be done on a 'leaf'

  // TODO: should add a policy object as input that will choose which edge to select.
  Node *Select(const Spec &spec); // Should only be done on non-leaves.

  void AddUtility(float utility);

  // From this node, what is the probability the given player will win.
  float ExpectedUtility(unsigned char playerIndex) const;

  vector<Edge> &GetChildren(void) { return children; }

  // private:
  State state;
  vector<Edge> children;
  vector<Action> nonExpandedActions;

  // This should be an enum maybe. This signifies which players turn it is for this node,
  // since this is an adversarial game, it is not always "my" turn, where "me" is defined
  // as the player at the root of the tree.
  unsigned char playerIndex; // index 0 is "me", index 1 is opponent.
  unsigned depth;
  bool isLeaf;

  unsigned totalTrials;
  float sumUtility;

  Node *eGreedySelect(void);
  Node *UCB1Select(const Spec &spec);
};
}
}
